# OBFINFO - Early obfuscation info file
# The obfinfo file is currently very new, so a lot is uncertain or undocumented.
# Take everything with a grain of salt

# CLASSES
# When looking through decompiled code you might notice that abstract enum methods are never implemented - this actually is not the case however as the implementations are in those invalid/empty enum classes!
a.a - Abstract class for all artifacts
a.b - Enum representation of the artifacts
ax - Star-related class, likely 
ck - Interface for everything that can be owned by a empire
f  - Alliance-related class
gw - Place where global configurations are held within

mo - Does not adjust stars
mp - Adjust stars to a square grid
mq - Adjust stars to a hex grid

# Fields
# Enums
a.b.a - Representation to a.c
a.b.b - Representation to a.d
a.b.c - Representation to a.e
a.b.d - Representation to a.f
a.b.e - Representation to a.i
a.b.f - Representation to a.k
a.b.g - Representation to a.l
a.b.h - Representation to a.m
a.b.i - Representation to a.n
a.b.j - Representation to a.o
a.b.k - Representation to a.j
a.b.l - Representation to a.r
a.b.m - Representation to a.s
# Proper fields
a.b.n - The class the enum is representing

ax.H - This is the wealth of all stars in the empire combined, should however NOT be used by anyone as it is reset every tick! Use (ax.I * ax.V) instead

f.c - The empires within the alliance, used for the isAlive method

le.x - This counts the amount of times le#z(void) was called.

# Methods
a.b#a(nd, ax) - Creates an instance of the class the enum is representing
a.b#a(String) - Enum#ValueOf with an sysout in case it isn't found
a.b#a(void)   - Enum#values but the result is converted into a vector
a.b#b(void)   - Returns a random artifact enum

ax#az(void)  - likely a  legacy method that was used for something more usefull, as of now it only counts the amount of attributes an empire has
ax#aJ(void)  - Used for blood purge effect calculations and messages
ax#aQ(void)  - the implementation of ax#az(void)
ax#I(void)   - the method returns a random number between 0 and 10 billion (exclusive) based on libGDX's random.

le#b(ax)   - This only increases a counter used within le#n(void)
le#v(void) - calling this method does neither increase le.x nor le.p, I'm guessing it does not perform any meaningfull simulation logic and only is used to animate certain parts of the game while it is semi-paused
